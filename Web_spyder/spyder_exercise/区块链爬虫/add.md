#对高级编程作业的补充

待补充内容：

- [x] 摘要
- [x] 爬虫和相关模块介绍
- [x] 模型介绍
- [ ] 目录的制作和排版
- [ ] 在使用模型的时候可以先介绍下
- [ ] 在word中插入代码块，使用网站：http://www.codeinword.com/
- [x] 小组分工

## 摘要
自2008年来中本聪在比特币白皮书中提到区块链至今，区块链技术以不可思议的速度发展起来，成为了当今最具影响力的创新技术之一。区块链技术的出现，为当下的大数据时代提供了强大的信任背书，创造了极高的信任价值。在这次的作业中，我们对近一年来以太坊的交易金额数据进行了抓取，先是使用Matplotlib模块对交易数据进行了可视化，然后使用Pytorch框架中的LSTM模型对其进行了一个时间序列分析，可以发现以太坊的交易金额在这一年来逐渐上涨，虽然有时候会有波动，但总体还是呈上升趋势。

关键词：区块链；LSTM模型；requests模块；加密货币；Pytroch
## 小组分工

陈强刚: 主要负责模型建立,熟悉深度学习和机器学习常用的理论知识，同时负责区块链相关
资料的查询.

邓铭杰: 论文写作,主要对论文整个框架进行整理，负责对论文的细节和具体内容进行撰写
，以及论文的排版，同时负责区块链部分相关的知识

朱伟林: 熟悉Python，Linux脚本语言的编写，熟悉numpy，pandas，等基础库的使
用，熟悉pytorch深度学习框架的使用，主要负责编程部分。

## 爬虫和相关模块介绍

爬虫介绍：爬虫就是通过编写代码，模拟浏览器访问网页，然后抓取网页上的数据。

以太坊介绍：以太坊（英文Ethereum）是一个开源的有智能合约功能的公共区块链平台，被称为区块链2.0，通过其专用加密货币以太币（Ether，简称“ETH”）提供去中心化的以太虚拟机（Ethereum Virtual Machine）来处理点对点合约。目前已经成为市值第二高的加密货币。

Pytorch介绍：PyTorch是一个Python的开源机器学习库。它用于自然语言处理等应用程序。它最初由Facebook人工智能研究小组开发，而优步的Pyro软件则用于概率编程。
最初，PyTorch由Hugh Perkins开发，作为基于Torch框架的LusJIT的Python包装器。有两种PyTorch变种。
PyTorch在Python中重新设计和实现Torch，同时为后端代码共享相同的核心C库。PyTorch开发人员调整了这个后端代码，以便有效地运行Python。他们还保留了基于GPU的硬件加速以及基于Lua的Torch的可扩展性功能。

区块链介绍：可以从狭义和广义两个层面来理解区块链的概念。 狭义上，区块链是一种以区块为基本单位的链式数据结构，区块中利用数字摘要对之前的交易历史进行校验，适合分布式记账场景下防篡改和可扩展性的需求。 广义上，区块链还指代基于区块链结构实现的分布式记账技术，包括分布式共识、隐私与安全保护、点对点通信技术、网络协议、智能合约等。

## 模型介绍

参考：https://wmathor.com/index.php/archives/1397/

LSTM又叫做长时间的短期记忆网络(Long Short-Term Memory Networks),在序列建模问题
上有一定优势，具有长时记忆功能。但是模型的并行效果比较差，运行需要花比较多的时
间。

LSTM 的关键是 cell 状态，即贯穿图顶部的水平线。cell 状态的传输就像一条传送带，向量从整个 cell 中穿过，只是做了少量的线性操作，这种结构能很轻松地实现信息从整个 cell 中穿过而不做改变（这样就可以实现长时期地记忆保留）

![](https://s2.ax1x.com/2020/02/05/1sD7Mn.png#shadow) 

LSTM 也有能力向 cell 状态中添加或删除信息，这是由称为门（gates）的结构仔细控制的。门可以选择性的让信息通过，它们由 sigmoid 神经网络层和逐点相乘实现
每个 LSTM 有三个这样的门结构来实现控制信息（分别是 forget gate 遗忘门；input gate 输入门；output gate 输出门）

- forget gate

LSTM 的第一步是决定要从 cell 状态中丢弃什么信息，这个决定是由一个叫做`forget gate layer`的 sigmoid 神经层来实现的。它的输入是$h_{t-1}$ 和 $x_t$ ，输出是一个数值都在 0~1 之间的向量（向量长度和$C_{t-1}$一样），表示让$C_{t-1}$的各部分信息通过的比重，0 表示不让任何信息通过，1 表示让所有信息通过.

- input gate

下一步是决定要让多少新的信息加入到 cell 状态中。实现这个需要包括两个步骤：首先，一个叫做`input gate layer`的 sigmoid 层决定哪些信息需要更新。另一个$tanh$层创建一个新的 candidate 向量$C_t$。最后，我们把这两个部分联合起来对 cell 状态进行更新
![](https://s2.ax1x.com/2020/02/05/1sRbU1.png#shadow) 

- output gate

最后，我们需要决定输出什么值了。这个输出主要是依赖于 cell 状态$C_t$ ，但是是经过筛选的版本。首先，经过一个 sigmoid 层，它决定$C_t$中的哪些部分将会被输出。接着，我们把 $C_t$ 通过一个 $tanh$ 层（把数值归一化到 - 1 和 1 之间），然后把 $tanh$ 层的输出和 simoid 层计算出来的权重相乘，这样就得到了最后的输出结果

![](https://s2.ax1x.com/2020/02/05/1s5dOO.png#shadow) 

